//------------------------------------------------------------------------------

//  <auto-generated>
//      This code was generated by:
//        TerminalGuiDesigner v1.1.0.0
//      You can make changes to this file and they will not be overwritten when saving.
//  </auto-generated>
// -----------------------------------------------------------------------------

using System.Diagnostics;
using System.Reflection;
using System.Text.RegularExpressions;
using Companion.Console.Enum;
using Companion.Console.Services;
using Google.Apis.Drive.v2.Data;
using HttpProgress;
using ImageMagick;
using Newtonsoft.Json;
using OpenQA.Selenium.DevTools.V112.Debugger;
using ProxyFill.Domain.Enum;
using ProxyFill.Shared.Model;
using Terminal.Gui;
using UglyToad.PdfPig.Content;
using UglyToad.PdfPig.Core;
using UglyToad.PdfPig.Writer;
using File = System.IO.File;

namespace Companion.Console;

public partial class MainWindow
{
    public string OrderPath { get; set; }
    public int TargetDPI { get; set; }
    public bool CompressImages { get; set; }
    public Game CurrentGame { get; set; }
    public List<ProxyCardDto> failedDownloads = new();
    public IEnumerable<ProxyCardDto> Cards { get; set; }
    public MemoryStream MainMemoryStream = new();

    private const int IMAGE_WIDTH_POINT = 198;
    private const int IMAGE_HEIGHT_POINT = 270;

    private const double IMAGE_WIDTH_INCH = 2.75;
    private const double IMAGE_HEIGHT_INCH = 3.75;

    private const string STEP_TEXT = "Step:";
    private const string TASK_TEXT = "Task:";
    private CancellationTokenSource cancellationTokenSource;
    private Progress<ICopyProgress> downloadProgress;


    public MainWindow()
    {
        InitializeComponent();
        btnGithub.Clicked += BtnGithubOnClicked;
        btnBuyCoffee.Clicked += BtnBuyCoffeeOnClicked;
        btnGeneratePDF.Clicked += () => Application.MainLoop.Invoke (BtnGeneratePDFOnClicked);
        if (!File.Exists("Data/Images/Lorcana/timestamp.txt"))
        {
            //download the images from github
            Application.MainLoop.Invoke (DownloadImagesFromGithub);
        }
    }

    private async void DownloadImagesFromGithub()
    {
        //download this zip from Github
        //https://github.com/nathenxbrewer/Proxy-Toolkit/raw/main/Data/Images/Lorcana/Lorcana.zip
        //extract it to the Data/Images/Lorcana folder
        SetStepText("Downloading Lorcana images...");
        var url = "https://github.com/nathenxbrewer/Proxy-Toolkit/raw/main/Data/Images/Lorcana/Lorcana.zip";
        var destinationPath = "Data/Images/Lorcana";
        var zipFilePath = Path.Combine(destinationPath, "Lorcana.zip");

        // Ensure the destination directory exists
        if (!Directory.Exists(destinationPath))
        {
            Directory.CreateDirectory(destinationPath);
        }

        try
        {
            downloadProgress = new Progress<ICopyProgress>();
            downloadProgress.ProgressChanged += (sender, args) => 
                ReportProgress(args.BytesTransferred, args.ExpectedBytes);
            var imageZip = await DownloadFileWithProgress(url, zipFilePath);
            //write imageZip byte array to zipFilePath
            File.WriteAllBytes(zipFilePath, imageZip);
            
            
            SetProgress(0, 1);
            // Extract the zip file
            SetStepText("Extracting Lorcana images...");
            System.IO.Compression.ZipFile.ExtractToDirectory(zipFilePath, destinationPath);
            SetStepText("Lorcana images downloaded!");

            // Optionally, delete the zip file after extraction
            File.Delete(zipFilePath);
        }
        catch (Exception e)
        {
            
        }

        
    }

    private async void BtnGeneratePDFOnClicked()
    {
        cancellationTokenSource = new CancellationTokenSource();
        OrderPath = txtFieldPath.Text.ToString();
        TargetDPI = GetTargetDPI(radioGroup.SelectedItem);
        CompressImages = TargetDPI > 0;
        //var listString = File.ReadAllText(OrderPath);
        //var listString = File.ReadAllText(OrderPath);
        SetStepText("Parsing deck list...");
        Cards = await Task.Run(ParseDeckList, cancellationTokenSource.Token);
        //var order = JsonConvert.DeserializeObject<ProxyFillOrder>(listString);
        //Cards = order.Cards.Where(x => x.FrontImage != null);
        if (CurrentGame is Game.Pokemon)
        {
            await Task.Run(DownloadImages, cancellationTokenSource.Token);
            await Task.Run(DownloadBacks, cancellationTokenSource.Token);
        }
        else
        {
            await Task.Run(FindFrontImages, cancellationTokenSource.Token);
        }

        await Task.Run(GeneratePdf, cancellationTokenSource.Token);
        SetStepText("Process complete!");
        SetTaskText($"PDF saved to Output folder.");
    }

    private async Task FindFrontImages()
    {
        // Look through the filesystem in Data/Images/Lorcana for the images that match each Card object in Cards
        // If the image is not found, add it to a list of failed downloads
        var imageFiles = Directory.GetFiles("Data/Images/Lorcana", "*.jpg", SearchOption.AllDirectories);

        foreach (var card in Cards)
        {
            var expectedImageName = $"{card.Name} - {card.Version}.jpg";

            if (!string.IsNullOrEmpty(card.Version))
            {
                if (card.Enchanted)
                {
                    expectedImageName = $"{card.Name} - {card.Version} (enchanted).jpg";
                }
            }
            else
            {
                expectedImageName = $"{card.Name}.jpg";
            }


            var imagePath = imageFiles.FirstOrDefault(file => Path.GetFileName(file).Equals(expectedImageName, StringComparison.OrdinalIgnoreCase));
            if (imagePath == null)
            {
                failedDownloads.Add(card);
            }
            else
            {
                card.FrontImage = imagePath;
                card.BackImage = Path.GetFullPath("Data/Images/Lorcana/Back/lorcana.jpg");
            }


        }
        
        //remove failedDownloads from Cards
        Cards = Cards.Where(x => !failedDownloads.Select(x=>x.CardId).Contains(x.CardId));

        if (failedDownloads.Any())
        {
            
        }
    }
    
    private async Task<int> ShowMessageBoxAsync(string title, string message, string[] buttons)
    {
        var tcs = new TaskCompletionSource<int>();

        Application.MainLoop.Invoke(() =>
        {
            var response = MessageBox.Query(title, message, "Yes", "No");
            tcs.SetResult(response);
        });

        return await tcs.Task;
    }

    private async Task<List<ProxyCardDto>> ParseDeckList()
    {
        //check if cards are Pokemon or Lorcana
        //Lorcana is in "3 Rafiki - Mystical Fighter" format
        //Pokemon is in "1 Bulbasaur DET 1" format
        var cards = new List<ProxyCardDto>();
        var lines = File.ReadAllLines(OrderPath);
        var lorcanaPattern = new Regex(@"^\d+ [\w\s'-]+(?: - [\w\s'-]+)?(?: \([\w\s'-]+\))?$");        
        var lorcanaMatches = lorcanaPattern.Match(lines[0]);

        var pokemonPattern = new Regex(@"^\d+ (?:[\w\s]+) [A-Z]{3} \d+$");
        var pokemonMatches = pokemonPattern.Match(lines[0]);
        
        CurrentGame = lorcanaMatches.Success ? Game.Lorcana : Game.Pokemon;
        
        switch (CurrentGame)
        {
            case Game.Lorcana:
            {
                using (var lorcastApiService = new LorcastApiService())
                {
                    var invalidCards = new List<string>();
                    foreach (var line in lines)
                    {
                        var pattern = @"^(?<quantity>\d+)\s(?<name>[\w\s'!]+)(?:\s-\s(?<version>[\w\s'!]+))?(?:\s\((?<enchanted>enchanted)\))?$";
                        var regex = new Regex(pattern);
                        var match = regex.Match(line);

                        if (!match.Success)
                        {
                            throw new ArgumentException("Line does not match the expected format.");
                        }

                        var quantity = int.Parse(match.Groups["quantity"].Value);
                        var name = match.Groups["name"].Value.Trim();
                        var version = match.Groups["version"].Value.Trim();
                        var enchanted = match.Groups["enchanted"].Value.Trim();

                        var hasVersion = !string.IsNullOrEmpty(version);
                        var isEnchanted = !string.IsNullOrEmpty(enchanted);

                        //use the Lorcast API to validate if this is a legit card
                        //if enchanted, add that to the search
                        IEnumerable<LorcastApiService.CardDto> matchingCards;
                        if (hasVersion && isEnchanted)
                        {
                            matchingCards = await lorcastApiService.SearchCardsByNameAndVersionAsync(name, version, true);
                        }
                        else if(hasVersion)
                        {
                            matchingCards = await lorcastApiService.SearchCardsByNameAndVersionAsync(name, version);
                        }
                        else
                        {
                            matchingCards = await lorcastApiService.SearchCardsByNameAsync(name);
                        }

                        if (matchingCards == null || !matchingCards.Any() || matchingCards.Count() > 1)
                        {
                            invalidCards.Add(line);
                            continue;
                        }

                        var matchingCard = matchingCards.First();
                        var card = new ProxyCardDto
                        {
                            Quantity = quantity,
                            Name = name,
                            Version = version,
                            Game = Game.Lorcana,
                            Enchanted = isEnchanted,
                            SetCode = matchingCard.Set.Code,
                            Type = matchingCard.Type,
                            CardId = matchingCard.Id,
                        };
                        cards.Add(card);
                    }

                }
                break;
            }            
            case Game.Pokemon:
            {
                break;
            }
        }

        return cards;
    }

    private int GetTargetDPI(int radioGroupSelectedItem)
    {
        switch (radioGroupSelectedItem)
        {
            case 0:
                return 300; 
            case 1:
                return 600;
            case 2:
                return 1200;
            case 3:
                return -1;
            default:
                return 300;
        }
    }

    private static async Task TestMethod()
    {
        await Task.Delay(10000);
    }

    private async Task DownloadImages()
    {
        lblStep.Text = "Testing...";
        SetStepText("Downloading front images...");
        if (!Directory.Exists("Images")) Directory.CreateDirectory("Images");

        //group by imageURL for duplicates, they may have multiple cards with different proxy art, so we cant group by card. 
        var groupedList = Cards.GroupBy(x => x.FrontImage).ToList();
        var imageCount = groupedList.Count;
        var x = 0;

        foreach (var group in groupedList)
        {
            var card = group.Select(x => x).First();
            var filename = $"{card.Name} {card.SetCode} {card.Number} ({GetGoogleDriveId(card.FrontImage)}).png";
            SetTaskText($"Downloading {filename}");
            var path = $"Images/{filename}";

            if (File.Exists(path))
            {
                SetTaskText($"{filename} already exists, continuing...");
                continue;
            }

            var downloadLink = group.Key;
            if (!await DownloadDriveFile(downloadLink, path))
                SetTaskText($"Failed to download {filename}...");
                failedDownloads.Add(card);

            x++;
            SetProgress(x,imageCount);
        }

        SetStepText($"Front images downloaded!");
    }

    private async Task DownloadBacks()
    {
        SetStepText($"Downloading back images...");
        if (!Directory.Exists("Backs")) Directory.CreateDirectory("Backs");

        //group by imageURL for duplicates, they may have multiple cards with different proxy art, so we cant group by card. 
        var groupedList = Cards.GroupBy(x => x.BackImage).ToList();
        var imageCount = groupedList.Count();
        var x = 0;
        foreach (var group in groupedList)
        {
            x++;
            var card = group.Select(x => x).First();
            var filename = card.BackImage.Replace(@"https://drive.google.com/uc?export=download&id=", "") + ".png";
            var path = $"Backs/{filename}";

            if (File.Exists(path))
            {
                SetStepText($"{filename} already exists, continuing...");
                continue;
            }

            var downloadLink = group.Key;
            if (!await DownloadDriveFile(downloadLink, path)) failedDownloads.Add(card);

            SetProgress(x, imageCount);
        }

        SetStepText($"Back images downloaded!");
    }
    

    private async Task<bool> DownloadDriveFile(string downloadLink, string path)
    {
        if (downloadLink.Contains("https://drive.google.com/uc?"))
        {
            var fileId = downloadLink.Substring(47);
            downloadLink =
                $"https://content.googleapis.com/drive/v2/files/{fileId}?key=AIzaSyBOGAtxTDZMJas_EkIRb0pVBpyQYpTaHXU&alt=media&source=downloadUrl";
        }

        using var client = new HttpClient();
        using var result = await client.GetAsync(downloadLink);
        if (!result.IsSuccessStatusCode) return false;
        var imageData = await result.Content.ReadAsByteArrayAsync();
        File.WriteAllBytes(path, imageData);

        //validate image is there
        if (!File.Exists(path)) return false;
        SetTaskText($"Downloaded {Path.GetFileName(path)} successfully!");
        return true;
    }

    private async Task<string> GeneratePdf()
    {
        SetStepText("Generating PDF...");
        var builder = new PdfDocumentBuilder();
        var groupedList = Cards.GroupBy(x => x.FrontImage);
        var i = 0;
        foreach (var group in groupedList)
        {
            var placement = new PdfRectangle(0, 0, IMAGE_WIDTH_POINT, IMAGE_HEIGHT_POINT);
            foreach (var card in group)
            {
                Application.DoEvents();
                for (int j = 0; j < card.Quantity; j++)
                {
                    //back
                    var backFileName = "";
                    var backFilePath = "";

                    if (CurrentGame is Game.Lorcana)
                    {
                        backFileName = Path.GetFileName(card.BackImage);
                        backFilePath = card.BackImage;
                    }
                    else
                    {
                        backFileName = GetGoogleDriveId(card.BackImage) + ".png";
                        backFilePath = Path.Combine("Backs", backFileName);
                    }
                    
                    var backPage = builder.AddPage(IMAGE_WIDTH_POINT, IMAGE_HEIGHT_POINT); //300 dpi
                    //SetTaskText($"Adding {backFileName} to PDF...");
                    var compressedBackImage = ProcessImageForPrinting(backFilePath);
                    var fileExtension = Path.GetExtension(backFilePath).ToLower();
                    if (fileExtension == ".jpg" || fileExtension == ".jpeg")
                    {
                        backPage.AddJpeg(compressedBackImage, placement);
                    }
                    else
                    {
                        backPage.AddPng(compressedBackImage, placement);
                    }

                    //front
                    var filename = "";
                    var filePath = "";
                    if (CurrentGame is Game.Lorcana)
                    {
                        filename = Path.GetFileName(card.FrontImage);
                        filePath = card.FrontImage;
                    }
                    else
                    {
                        filename = $"{card.Name} {card.SetCode} {card.Number} ({GetGoogleDriveId(card.FrontImage)}).png";
                        filePath = Path.Combine("Images", filename);

                    }
                    var page = builder.AddPage(IMAGE_WIDTH_POINT, IMAGE_HEIGHT_POINT); //300 dpi

                    using var stream = new MemoryStream();

                    SetTaskText($"Adding {Path.GetFileName(filePath)} to PDF...");
                    var compressedImage = ProcessImageForPrinting(filePath);
                    SetProgress(i, Cards.Sum(x=>x.Quantity));
                    if (fileExtension == ".jpg" || fileExtension == ".jpeg")
                    {
                        page.AddJpeg(compressedImage, placement);
                    }
                    else
                    {
                        page.AddPng(compressedImage, placement);
                    }                    
                    i++;
                }
            }
        }

        builder.DocumentInformation.Author = "ProxyFill";
        builder.DocumentInformation.Subject =
            "Created by ProxyFill Companion. https://github.com/nathenxbrewer/ProxyFill";
        var documentBytes = builder.Build();
        var deckFileName = Path.GetFileNameWithoutExtension(OrderPath);
        if (!Directory.Exists("Output")) Directory.CreateDirectory("Output");

        var name = string.IsNullOrWhiteSpace(deckFileName) ? $"{CurrentGame} Deck - {DateTime.Now:MM-dd-yyyy}" : deckFileName;
        var pdfFilePath = Path.Combine("Output", $"{name} ({TargetDPI} dpi).pdf");
        SetTaskText($"Exporting PDF to {pdfFilePath}");
        File.WriteAllBytes(pdfFilePath, documentBytes);
        SetStepText("PDF export complete!");
        
        SetProgress(i,groupedList.Count());
        return pdfFilePath;
    }

    private static string GetGoogleDriveId(string driveURL)
    {
        return driveURL.Replace(@"https://drive.google.com/uc?export=download&id=", "");
    }

    private MemoryStream ProcessImageForPrinting(string filePath)
    {
        var filename = Path.GetFileName(filePath);
        //SetTaskText("Checking if image needs compressed...");
        using (var image = new MagickImage(filePath))
        {
            if (CompressImages)
            {
                var width = image.Width;
                var height = image.Height;
                var dpi = (width / IMAGE_WIDTH_INCH + height / IMAGE_HEIGHT_INCH) / 2;
                //reset memorystream
                MainMemoryStream.Position = 0;
                MainMemoryStream.SetLength(0);
                if (dpi > TargetDPI)
                {
                    //SetTaskText($"Compressing {filename}...");
                    var dpiPercent = TargetDPI / dpi * 100;
                    image.Resize(new Percentage(dpiPercent));
                }
            }
            
            image.Write(MainMemoryStream);
            var colorProfileStream = Assembly.GetExecutingAssembly()
                .GetManifestResourceStream("Companion.Console.Profiles.CGATS21_CRPC1.icc");
            var profile = new ColorProfile(colorProfileStream);
            image.SetProfile(profile);

            MainMemoryStream.Position = 0;

            return MainMemoryStream;
        }
    }

    private async Task<byte[]?> DownloadFileWithProgress(string url, string destinationPath)
    {
        try
        {
            using var client = new HttpClient();
            using var downloadStream = new MemoryStream();
            var result = await client.GetAsync(url, downloadStream, downloadProgress);
            return result.IsSuccessStatusCode ? downloadStream.ToArray() : null;
        }
        catch (Exception ex)
        {
            return null;
        }
    }
    private void ReportProgress(long bytesRead, long totalBytes)
    {
        SetProgress((int)bytesRead,(int)(totalBytes));
        //SetTaskText($"Downloaded {progress:F2}%");
    }
    private void SetProgressText(string text)
    {
        Application.MainLoop.Invoke(() =>
        {
            progressBar.Text = text;
            progressBar.SetNeedsDisplay();
        });
    }
    private void BtnBuyCoffeeOnClicked()
    {
        Process.Start(new ProcessStartInfo("https://www.buymeacoffee.com/nathenxbrewer") { UseShellExecute = true });
    }

    private void BtnGithubOnClicked()
    {
        Process.Start(new ProcessStartInfo("https://github.com/nathenxbrewer/ProxyFill") { UseShellExecute = true });
    }

    private void SetTaskText(string text)
    {
        Application.MainLoop.Invoke(()=>{
            lblTask.Text = $"{TASK_TEXT} {text}";
            lblTask.SetNeedsDisplay();
        });
        
    }
    private void SetStepText(string text)
    {
        Application.MainLoop.Invoke(()=>{
            lblStep.Text = $"{STEP_TEXT} {text}";
            lblStep.SetNeedsDisplay();
        });
    }
    
    private void SetProgress(int count, int max)
    {
        progressBar.Fraction = (float)count / max;
        progressBar.Text = Math.Round(progressBar.Fraction * 100, 0) + "%";
    }
}